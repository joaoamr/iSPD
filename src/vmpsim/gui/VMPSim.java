/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package vmpsim.gui;

import NumerosAleatorios.GeracaoNumAleatorios;
import ispd.externo.cloudAlloc.global.NHCVMPonline;
import ispd.gui.JResultados;
import ispd.gui.JResultadosCloud;
import ispd.gui.JResultadosCloudEx;
import ispd.gui.JSimulacao;
import ispd.motor.ProgressoSimulacao;
import ispd.motor.SimulacaoSequencialCloud;
import ispd.motor.SimulacaoSequencialCloudAlocacaoSomente;
import ispd.motor.filas.RedeDeFilasCloud;
import ispd.motor.filas.Tarefa;
import ispd.motor.filas.servidores.CS_Comunicacao;
import ispd.motor.filas.servidores.CS_Processamento;
import ispd.motor.filas.servidores.CentroServico;
import ispd.motor.filas.servidores.implementacao.CS_Internet;
import ispd.motor.filas.servidores.implementacao.CS_Link;
import ispd.motor.filas.servidores.implementacao.CS_MaquinaCloud;
import ispd.motor.filas.servidores.implementacao.CS_MasterVirtualMac;
import ispd.motor.filas.servidores.implementacao.CS_Switch;
import ispd.motor.filas.servidores.implementacao.CS_VMM;
import ispd.motor.filas.servidores.implementacao.CS_VirtualMac;
import ispd.motor.metricas.MetricasUsuarios;
import vmpsim.util.cloudnetwork.FatTree;
import vmpsim.util.cloudnetwork.Star;
import vmpsim.util.cloudnetwork.Tree;

import java.awt.Color;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JOptionPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.StyleConstants;

/**
 *
 * @author Jo√£o Antonio Magri Rodrigues
 */
public class VMPSim extends javax.swing.JFrame {
    private float matrizTrafego[][];
    ArrayList<CS_Processamento> masterlist = new ArrayList<CS_Processamento>();
    ArrayList<CS_MaquinaCloud> hostlist = new ArrayList<CS_MaquinaCloud>();
    ArrayList<CS_Comunicacao> switchlist = null;
    ArrayList<CS_VirtualMac> vms = null;
    ArrayList<Tarefa> loads = new ArrayList<Tarefa>();
    
    private RedeDeFilasCloud datacenter;
    private ProgressoSimulacao progressosim = new ProgressoSimulacao() {
            @Override
            public void incProgresso(int n) {
               
            }
            @Override
            public void print(String text, Color cor) {
               System.out.println(text);
        }
    };
    
    /**
     * Creates new form VMPSim
     */
    public VMPSim() {
        initComponents();
        this.setLocationRelativeTo(null);
        startParams();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        memoryMinSpinner = new javax.swing.JSpinner();
        diskMinSpinner = new javax.swing.JSpinner();
        coresMinSpinner = new javax.swing.JSpinner();
        powerMinSpinner = new javax.swing.JSpinner();
        jLabel10 = new javax.swing.JLabel();
        hostsSpinner = new javax.swing.JSpinner();
        memoryMaxSpinner = new javax.swing.JSpinner();
        diskMaxSpinner = new javax.swing.JSpinner();
        coresMaxSpinner = new javax.swing.JSpinner();
        powerMaxSpinner = new javax.swing.JSpinner();
        Switches = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        latencySpinner = new javax.swing.JSpinner();
        speedSpinner = new javax.swing.JSpinner();
        topologyCombo = new javax.swing.JComboBox();
        jLabel11 = new javax.swing.JLabel();
        switchesSpinner = new javax.swing.JSpinner();
        jLabel12 = new javax.swing.JLabel();
        openButton = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        hpcSpinner = new javax.swing.JSpinner();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        placementCombo = new javax.swing.JComboBox();
        vmMinMem = new javax.swing.JSpinner();
        vmMaxMem = new javax.swing.JSpinner();
        jLabel13 = new javax.swing.JLabel();
        vmMinDisk = new javax.swing.JSpinner();
        vmMaxDisk = new javax.swing.JSpinner();
        jLabel14 = new javax.swing.JLabel();
        vmMinCores = new javax.swing.JSpinner();
        vmMaxCores = new javax.swing.JSpinner();
        jLabel15 = new javax.swing.JLabel();
        vmMinPower = new javax.swing.JSpinner();
        vmMaxPower = new javax.swing.JSpinner();
        jLabel16 = new javax.swing.JLabel();
        arguments = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("VMPSim");
        setResizable(false);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Processing nodes"));

        jLabel1.setText("Memory");

        jLabel2.setText("Disk");

        jLabel3.setText("Cores");

        jLabel4.setText("Power");

        jLabel10.setText("Hosts");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel3)
                        .addComponent(jLabel4))
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(hostsSpinner, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 154, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(powerMinSpinner, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 71, Short.MAX_VALUE)
                            .addComponent(coresMinSpinner, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(diskMinSpinner, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(memoryMinSpinner, javax.swing.GroupLayout.Alignment.LEADING))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(memoryMaxSpinner, javax.swing.GroupLayout.DEFAULT_SIZE, 73, Short.MAX_VALUE)
                            .addComponent(diskMaxSpinner)
                            .addComponent(coresMaxSpinner)
                            .addComponent(powerMaxSpinner)))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(0, 11, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel10, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(hostsSpinner, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(memoryMinSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(memoryMaxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(diskMinSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(diskMaxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(coresMinSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(coresMaxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(powerMinSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(powerMaxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        Switches.setBorder(javax.swing.BorderFactory.createTitledBorder("Switches"));

        jLabel5.setText("Latency");

        jLabel6.setText("Speed");

        topologyCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Fat-tree" , "Star" }));
        topologyCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topologyComboActionPerformed(evt);
            }
        });

        jLabel11.setText("Ports");

        jLabel12.setText("Topology");

        javax.swing.GroupLayout SwitchesLayout = new javax.swing.GroupLayout(Switches);
        Switches.setLayout(SwitchesLayout);
        SwitchesLayout.setHorizontalGroup(
            SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(SwitchesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel11)
                    .addComponent(jLabel12, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(switchesSpinner, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(latencySpinner, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(speedSpinner)
                    .addComponent(topologyCombo, 0, 158, Short.MAX_VALUE)))
        );
        SwitchesLayout.setVerticalGroup(
            SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(SwitchesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(latencySpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(speedSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel11)
                    .addComponent(switchesSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(SwitchesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(topologyCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel12))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        openButton.setText("Clear");
        openButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openButtonActionPerformed(evt);
            }
        });

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Virtual Machines"));

        jLabel7.setText("Nodes");

        jLabel8.setText("Memory");

        jLabel9.setText("Placement Algorithm:");

        placementCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] {"FirstFit", "FirstFitDecreasing", "RoundRobin"}));
        placementCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                placementComboActionPerformed(evt);
            }
        });

        jLabel13.setText("Disk");

        jLabel14.setText("Cores");

        jLabel15.setText("Power");

        jLabel16.setText("Arguments");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel7)
                    .addComponent(jLabel13)
                    .addComponent(jLabel14)
                    .addComponent(jLabel15))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(vmMinPower, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(vmMaxPower))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(vmMinCores, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(vmMaxCores))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(vmMinDisk, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(vmMaxDisk))
                    .addComponent(hpcSpinner)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(vmMinMem, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(vmMaxMem, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel9)
                    .addComponent(placementCombo, 0, 155, Short.MAX_VALUE)
                    .addComponent(jLabel16)
                    .addComponent(arguments)))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel7)
                    .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(hpcSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(placementCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vmMinMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel8)
                    .addComponent(vmMaxMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel13)
                    .addComponent(vmMinDisk, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vmMaxDisk, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel16))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel14)
                    .addComponent(vmMinCores, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vmMaxCores, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(arguments, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel15)
                    .addComponent(vmMinPower, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vmMaxPower, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        jButton1.setText("Play");
        jButton1.setActionCommand("play");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(Switches, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(openButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Switches, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(openButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        int hosts = (Integer)hostsSpinner.getValue();
        int ports = (Integer)switchesSpinner.getValue();
        int hpcvms = (Integer)hpcSpinner.getValue();
        int miscvms = 0;
        Random rnd = new Random();
        
        ArrayList<CS_Processamento> masterlist = new ArrayList<CS_Processamento>();
        ArrayList<CS_MaquinaCloud> hostlist = new ArrayList<CS_MaquinaCloud>();
        ArrayList<CS_Comunicacao> switchlist = null;
        ArrayList<CS_VirtualMac> vms = new ArrayList<CS_VirtualMac>();
        ArrayList<Tarefa> loads = new ArrayList<Tarefa>();
        
        int cores = rnd.nextInt(((Integer)coresMaxSpinner.getValue()) - (Integer)coresMinSpinner.getValue() + 1) + (Integer)coresMinSpinner.getValue();
        double power = rnd.nextInt(((Integer)powerMaxSpinner.getValue()) - (Integer)powerMinSpinner.getValue() + 1) + (double)((Integer)powerMinSpinner.getValue());
        double memory = rnd.nextInt(((Integer)memoryMaxSpinner.getValue()) - (Integer)memoryMinSpinner.getValue() + 1) + ((double)(Integer)memoryMinSpinner.getValue());
        double disk = rnd.nextInt(((Integer)diskMaxSpinner.getValue()) - (Integer)diskMinSpinner.getValue() + 1) + ((double)(Integer)diskMinSpinner.getValue());
        double speed = ((double)(Integer)speedSpinner.getValue());
        double latency = ((double)(Integer)latencySpinner.getValue());
        String placementalgorithm = placementCombo.getSelectedItem().toString();
        String topology = topologyCombo.getSelectedItem().toString();
        
        CS_VMM master = null;
        CS_MaquinaCloud host;
        
        master = new CS_VMM("Master", "System", power, memory, disk, 1, "RoundRobin", placementalgorithm);
        master.getAlocador().iniciarMatrizDeCustos(topology, hosts, ports);
        master.getAlocador().processarArgumentos(arguments.getText());
            
        masterlist.add(master);
        
        ArrayList <String> users = new ArrayList<String>();
        
        for(int i = 0; i < hosts; i++){            
                host = new CS_MaquinaCloud("Host #" + i, "System", power, cores, 1, memory, disk, 0, 0, 0);
                host.addMestre(master);
                master.addEscravo(host);
                hostlist.add(host);
                cores = rnd.nextInt(((Integer)coresMaxSpinner.getValue()) - (Integer)coresMinSpinner.getValue() + 1) + (Integer)coresMinSpinner.getValue();
                power = rnd.nextInt(((Integer)powerMaxSpinner.getValue()) - (Integer)powerMinSpinner.getValue() + 1) + (double)((Integer)powerMinSpinner.getValue());
                memory = rnd.nextInt(((Integer)memoryMaxSpinner.getValue()) - (Integer)memoryMinSpinner.getValue() + 1) + ((double)(Integer)memoryMinSpinner.getValue());
                disk = rnd.nextInt(((Integer)diskMaxSpinner.getValue()) - (Integer)diskMinSpinner.getValue() + 1) + ((double)(Integer)diskMinSpinner.getValue());
                
                int proc = rnd.nextInt(3) + 1;
                memory = (rnd.nextInt(7) + 1) * 256;
                cores = proc*28;
                power = 38*proc;
            }
        
        if(this.vms == null){
                       
            this.vms = vmList(master, loads, hpcvms , miscvms, users, (Integer)vmMinCores.getValue(), (Integer)vmMaxCores.getValue(), (Integer)vmMinMem.getValue(), (Integer)vmMaxMem.getValue(), (Integer)vmMinDisk.getValue(), (Integer)vmMaxDisk.getValue(), (Integer)vmMinPower.getValue(), (Integer)vmMaxPower.getValue());
            /*
            this.hostlist = new ArrayList<CS_MaquinaCloud>(hostlist);
            this.masterlist = new ArrayList<CS_Processamento>(masterlist);
            this.vms = new ArrayList<CS_VirtualMac>(vms);*/
            this.loads = new ArrayList<Tarefa>(loads);
            
        }//else{
            /*hostlist.clear();
            masterlist.clear();*/
            vms = new ArrayList<CS_VirtualMac>(vms.size());
            loads.clear();
        
           
            
            /*for(int i = 0; i < this.hostlist.size(); i++){
                cores = this.hostlist.get(i).getNumeroProcessadores();
                power = this.hostlist.get(i).getPoderComputacional();
                memory = this.hostlist.get(i).getMemoriaDisponivel();
                disk = this.hostlist.get(i).getDiscoDisponivel(); 
                 
                host = new CS_MaquinaCloud("Host #" + i, "System", power, cores, 1, memory, disk, 0, 0, 0);
                host.addMestre(master);
                master.addEscravo(host);
                hostlist.add(host);

            }*/
            
            MetricasUsuarios mu = new MetricasUsuarios();
            master.getEscalonador().setMetricaUsuarios(mu);
            
            CS_MasterVirtualMac mastervm = null;
            CS_VirtualMac slavevm;
            int userid = 0;
            
            for(int i = 0; i < this.vms.size(); i++){
                
                if(this.vms.get(i) instanceof CS_MasterVirtualMac ){
                    mastervm = new CS_MasterVirtualMac(this.vms.get(i).getId(), this.vms.get(i).getProprietario(), this.vms.get(i).getNumeroProcessadores(), this.vms.get(i).getPoderNecessario()/this.vms.get(i).getNumeroProcessadores(), this.vms.get(i).getMemoriaDisponivel(), this.vms.get(i).getDiscoDisponivel(), "RoundRobin", "Linux");
                    mastervm.addVMM(master);
                    mastervm.getEscalonador().setMetricaUsuarios(mu);
                    mastervm.setGlobalId(i);
                    mu.addUsuario("HPC #" + userid, 0.0);
                    users.add("HPC #" + userid);
                    userid++;
                    vms.add(mastervm);
            
                }
                else{
                    slavevm = new CS_VirtualMac(this.vms.get(i).getId(), this.vms.get(i).getProprietario(), this.vms.get(i).getNumeroProcessadores(), this.vms.get(i).getPoderNecessario()/this.vms.get(i).getNumeroProcessadores(), this.vms.get(i).getMemoriaDisponivel(), this.vms.get(i).getDiscoDisponivel(), "Linux");
                    slavevm.setGlobalId(i);
                    slavevm.addVMM(master);
                    slavevm.setMestre(mastervm);
                    mastervm.addEscravos(slavevm);
                    vms.add(slavevm);
                }
            
            }
            
            master.getAlocador().setMatrizTrafego(matrizTrafego);
            
            for(int i = 0; i < this.loads.size(); i++){
                Tarefa t = new Tarefa(this.loads.get(i));
                loads.add(t);
                int index;
                index = this.vms.indexOf(t.getOrigem());
                t.setOrigem(vms.get(index));
                index = this.vms.indexOf(t.getLocalProcessamento());
                t.setLocalProcessamento(vms.get(index));
                t.getSubTarefas().clear();
                
                for(int j = 0; j < this.loads.get(i).getSubTarefas().size(); j++){
                    Tarefa subt = new Tarefa(this.loads.get(i).getSubTarefas().get(j));
                    index = this.vms.indexOf(subt.getLocalProcessamento());
                    subt.setLocalProcessamento(vms.get(index));
                    index = this.vms.indexOf(subt.getOrigem());
                    subt.setOrigem(vms.get(index));
                    t.addSubTarefa(subt);
                }                
            }
          
        //}     
        
        try{
        
        if(topology.equals("Star"))
            switchlist = Star.assemblyLinks(masterlist, hostlist, speed, latency);
        
        if(topology.equals("Tree"))
            switchlist = Tree.assemblyLinks(masterlist, hostlist, speed, latency, ports);
        
        if(topology.equals("Fat-tree"))
            switchlist = FatTree.assemblyLinks(masterlist, hostlist, speed, latency, ports);
        }
        catch(Exception e) {
        	JOptionPane.showMessageDialog(null,"Fail while assembling the network.\nMake sure the number of hosts and switches ports matches with the chosen topology.","Bad arguments", JOptionPane.ERROR_MESSAGE);
        	return;
        }
       
        ArrayList<CS_Internet> internet = new ArrayList<CS_Internet>();

        datacenter = new RedeDeFilasCloud(masterlist, hostlist, vms, switchlist, internet);

        for(int i = 0; i < vms.size(); i++)
            master.addVM(vms.get(i));

        ArrayList<Double> userpower = new ArrayList<Double>();

        for(int i = 0; i < users.size(); i++)
            userpower.add(0.0);

        for(int i = 0; i < hostlist.size(); i++){
            MetricasUsuarios mu2 = new MetricasUsuarios();
            mu2.addAllUsuarios(users, userpower);
            datacenter.setUsuarios(users);
        }
        
        SimulacaoSequencialCloudAlocacaoSomente sim = new SimulacaoSequencialCloudAlocacaoSomente(progressosim, datacenter, loads);
        sim.simular();
        
        master.getAlocador().setMatrizTrafego(null);
        master.getAlocador().setMatrizCusto(null);
        sim = null;
        datacenter = null;
        loads.clear();
        switchlist.clear();
        masterlist.clear();
        hostlist.clear();
        
        System.gc();
        System.out.println("Fim");
        //JResultadosCloudEx results = new JResultadosCloudEx(null, sim.getMetricasCloud(), datacenter, loads);
        //results.setVisible(true);
    }//GEN-LAST:event_jButton1ActionPerformed
    
    private ArrayList<CS_VirtualMac> vmList(CS_VMM master, ArrayList<Tarefa> loads, int hpcvms, int miscvms, ArrayList <String> users, int mincore, int maxcore, double minmem, double maxmem, double mindisk, double maxdisk, double minpower, double maxpower){
        int loadid = 0;
        int vmid = 0;
        hpcvms++;
        GeracaoNumAleatorios random = new GeracaoNumAleatorios((int)System.currentTimeMillis());
        ArrayList<CS_VirtualMac> vmlist = new ArrayList<CS_VirtualMac>();
        Random rnd = new Random();
        int dimfactor, groupsize, mem, core, comm, comp;
        
        matrizTrafego = new float[hpcvms][hpcvms];
        for(int i = 0 ; i < hpcvms; i++)
            for (int j = 0; j < hpcvms; j++){
                matrizTrafego[i][j] = 0;
            }
        
        
        MetricasUsuarios mu = new MetricasUsuarios();
        master.getEscalonador().setMetricaUsuarios(mu);
        
        for(int i = 0; vmid < hpcvms - 1; i++){
            ArrayList<CS_VirtualMac> cluster = new ArrayList<CS_VirtualMac>();
            int cores = rnd.nextInt(maxcore - mincore + 1) + mincore;
            double memory = (double)rnd.nextInt((int)maxmem - (int)minmem + 1) + minmem;
            double disk = (double)rnd.nextInt((int)maxdisk - (int)mindisk + 1) + mindisk;
            double power = (double)rnd.nextInt((int)maxpower - (int)minpower + 1) + minpower;
            CS_MasterVirtualMac vmmaster = new CS_MasterVirtualMac("Master HPC #" + i, "HPC #" + i, cores, power, memory, disk, "RoundRobin", "Linux");	
            vmlist.add(vmmaster);
            vmmaster.addVMM(master);
            vmmaster.getEscalonador().setMetricaUsuarios(mu);
            vmmaster.setGlobalId(vmid);
            vmid++;
            //master.addVM(vmmaster);
            cluster.add(vmmaster);
            int clustersize = (int) Math.pow(2, (double)rnd.nextInt(8)) - 1;
            //clustersize = 256;
            System.out.println("Cluster size: " + clustersize);
            for(int j = 0; j < clustersize && i + j < hpcvms; j++){
                memory = (double)rnd.nextInt((int)maxmem - (int)minmem + 1) + minmem;
                disk = (double)rnd.nextInt((int)maxdisk - (int)mindisk + 1) + mindisk;
                power = (double)rnd.nextInt((int)maxpower - (int)minpower + 1) + minpower;
                cores = rnd.nextInt(maxcore - mincore + 1) + mincore;
                CS_VirtualMac vm = new CS_VirtualMac("HPC #" + i + ": VM #" + j, "HPC #" + i, cores, power, memory, disk, "Linux");
                vm.addVMM(master);
                vm.setMestre(vmmaster);
                vmmaster.addEscravos(vm);
                vmlist.add(vm);
                vm.setGlobalId(vmid);
                vmid++;
                //master.addVM(vm);
                cluster.add(vm);
                if(vmid == hpcvms - 1)
                    break;
            }
            if(cluster.size() > 1){
                for(int j = 0; j < cluster.size() - 1; j++){
                    for(int k = j + 1; k < cluster.size(); k++){
                        float d = gerarFluxo();   
                        matrizTrafego[cluster.get(j).getGlobalId()][cluster.get(k).getGlobalId()] = d;
                        matrizTrafego[cluster.get(k).getGlobalId()][cluster.get(j).getGlobalId()] = d; 
                    }
                }
                
                for(int j = 1; j < cluster.size(); j++){
                    float d;
                    d = gerarFluxo();
                    matrizTrafego[cluster.get(0).getGlobalId()][cluster.get(j).getGlobalId()] = d;
                    matrizTrafego[cluster.get(j).getGlobalId()][cluster.get(0).getGlobalId()] = d;
                    
                    Tarefa tarefa = new Tarefa(loadid,"HPC #" + i, "HPC App " + i + " " + j,vmmaster, d,0.0009765625,100000,100000 + i);
                    tarefa.setLocalProcessamento(cluster.get(j));
                    loads.add(tarefa);
                    loadid++;
                    for(int k = j + 1; k < cluster.size(); k++){                     
                        d = gerarFluxo();
                        matrizTrafego[cluster.get(k).getGlobalId()][cluster.get(j).getGlobalId()] = d;
                        matrizTrafego[cluster.get(j).getGlobalId()][cluster.get(k).getGlobalId()] = d;
                        Tarefa subtarefa = new Tarefa(loadid,"HPC #" + i, "HPC App " + i + " " + j,cluster.get(j), d ,0.0009765625,100000,100000 + i + k);
                        loadid++;
                        subtarefa.setLocalProcessamento(cluster.get(k));
                        //tarefa.addSubTarefa(subtarefa);
                    }
                }
               
            }
           
            mu.addUsuario("HPC #" + i, 0.0);
            users.add("HPC #" + i);
        }
       
        master.getAlocador().setMatrizTrafego(matrizTrafego);
        try{salvarVms(); } catch(Exception e){};
        return vmlist;
    }
    private void startParams(){
        memoryMinSpinner.setValue(256);
        memoryMaxSpinner.setValue(2048);
        hostsSpinner.setValue(16);
        diskMinSpinner.setValue(2048);
        diskMaxSpinner.setValue(8192);
        coresMinSpinner.setValue(32);
        coresMaxSpinner.setValue(96);
        latencySpinner.setValue(10);
        powerMinSpinner.setValue(10000);
        powerMaxSpinner.setValue(20000);
        speedSpinner.setValue(100000);
        switchesSpinner.setValue(4);
        vmMinMem.setValue(2);
        vmMaxMem.setValue(64);
        vmMinDisk.setValue(128);
        vmMaxDisk.setValue(1024);
        vmMinPower.setValue(1000);
        vmMaxPower.setValue(5000);
        vmMinCores.setValue(1);
        vmMaxCores.setValue(64);
    }
    
    private void salvarVms() throws FileNotFoundException, IOException{
        ObjectOutputStream objectOut = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream("vmlist")));
        objectOut.writeObject(vms);
        objectOut.close();
    }
    
    private float gerarFluxo(){
        Random rnd = new Random();
        double d;
        int f = rnd.nextInt(3) + 1;
        if(rnd.nextInt(100) < 75)
            d = rnd.nextGaussian()*5 + 5;
        else
            d = rnd.nextGaussian()*5 + 16;
        
        d = rnd.nextGaussian()*f*5 + f*5;
        
        //d = rnd.nextInt(2000);
        if(d < 0)
            d *= -1;
        
        return (float)d;
    }
    
    private void topologyComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topologyComboActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_topologyComboActionPerformed

    private void openButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openButtonActionPerformed
        vms = null;
        CS_Processamento.iniciarMapa();
    }//GEN-LAST:event_openButtonActionPerformed

    private void placementComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_placementComboActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_placementComboActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VMPSim.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VMPSim.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VMPSim.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VMPSim.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VMPSim().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel Switches;
    private javax.swing.JTextField arguments;
    private javax.swing.JSpinner coresMaxSpinner;
    private javax.swing.JSpinner coresMinSpinner;
    private javax.swing.JSpinner diskMaxSpinner;
    private javax.swing.JSpinner diskMinSpinner;
    private javax.swing.JSpinner hostsSpinner;
    private javax.swing.JSpinner hpcSpinner;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JSpinner latencySpinner;
    private javax.swing.JSpinner memoryMaxSpinner;
    private javax.swing.JSpinner memoryMinSpinner;
    private javax.swing.JButton openButton;
    private javax.swing.JComboBox<String> placementCombo;
    private javax.swing.JSpinner powerMaxSpinner;
    private javax.swing.JSpinner powerMinSpinner;
    private javax.swing.JSpinner speedSpinner;
    private javax.swing.JSpinner switchesSpinner;
    private javax.swing.JComboBox<String> topologyCombo;
    private javax.swing.JSpinner vmMaxCores;
    private javax.swing.JSpinner vmMaxDisk;
    private javax.swing.JSpinner vmMaxMem;
    private javax.swing.JSpinner vmMaxPower;
    private javax.swing.JSpinner vmMinCores;
    private javax.swing.JSpinner vmMinDisk;
    private javax.swing.JSpinner vmMinMem;
    private javax.swing.JSpinner vmMinPower;
    // End of variables declaration//GEN-END:variables
}
